{"version":3,"file":"raxSearch.dev.js","sources":["webpack://raxSearch/webpack/universalModuleDefinition","webpack://raxSearch/./index.ts","webpack://raxSearch/./src/common/common.ts","webpack://raxSearch/./src/common/distanceCalculator.ts","webpack://raxSearch/./src/exactMatch/patternFinder.ts","webpack://raxSearch/./src/fuzzyMatch/fuzzyMatcher.ts","webpack://raxSearch/webpack/bootstrap","webpack://raxSearch/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"raxSearch\"] = factory();\n\telse\n\t\troot[\"raxSearch\"] = factory();\n})(this, function() {\nreturn ","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar fuzzyMatcher = require(\"./src/fuzzyMatch/fuzzyMatcher\");\r\nvar exactMatcher = require(\"./src/exactMatch/patternFinder\");\r\n// import * as minHashLsh from './src/shingMinLos/minHashLsh'; // dont expose min hash lsh currently\r\n// console.log(fuzzyMatcher);\r\n// console.log(exactMatcher);\r\n// // console.log(minHashLsh);\r\nmodule.exports = {\r\n    fuzzyMatcher: fuzzyMatcher,\r\n    exactMatcher: exactMatcher\r\n};\r\n","\"use strict\";\r\nvar __read = (this && this.__read) || function (o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n};\r\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.getVectorLength = exports.getDotProduct = exports.randomPermutationGenerator = exports.normalizeToVectors = exports.getShinglesDisregardRepeated = exports.getShinglesPreserveRepeated = void 0;\r\n/**\r\n * Shingling the string (preserve repeated)\r\n * for example : str \"abcbc\" is shingled to [ab, bc, cb, bc] if the shingle size is 2\r\n * @param {String} string\r\n * @param {Number} shingleSize\r\n * @return {Array}\r\n */\r\nfunction getShinglesPreserveRepeated(string, shingleSize) {\r\n    if (shingleSize >= string.length)\r\n        return [string];\r\n    var arr = [];\r\n    var noSpacesString = \"\";\r\n    for (var i = 0; i < string.length; i++) {\r\n        if (string.charAt(i) !== \" \") {\r\n            noSpacesString += string.charAt(i);\r\n        }\r\n    }\r\n    for (var i = 0; i + shingleSize - 1 < noSpacesString.length; i++) {\r\n        arr.push(noSpacesString.substring(i, i + shingleSize));\r\n    }\r\n    return arr;\r\n}\r\nexports.getShinglesPreserveRepeated = getShinglesPreserveRepeated;\r\n/**\r\n * Shingling the string (disregard repeated)\r\n * for example : str \"abcbc\" is shingled to [ab, bc, cb] if the shingle size is 2\r\n * @param {String} string\r\n * @param {Number} shingleSize\r\n * @return {Array}\r\n */\r\nfunction getShinglesDisregardRepeated(string, shingleSize) {\r\n    if (shingleSize >= string.length)\r\n        return [string];\r\n    var arr = [];\r\n    var lookupTable = {};\r\n    var noSpacesString = \"\";\r\n    for (var i = 0; i < string.length; i++) {\r\n        if (string.charAt(i) !== \" \") {\r\n            noSpacesString += string.charAt(i);\r\n        }\r\n    }\r\n    for (var i = 0; i + shingleSize - 1 < noSpacesString.length; i++) {\r\n        var subString = noSpacesString.substring(i, i + shingleSize);\r\n        if (!lookupTable[subString]) {\r\n            arr.push(subString);\r\n            lookupTable[subString] = 1; //mark as existed\r\n        }\r\n    }\r\n    return arr;\r\n}\r\nexports.getShinglesDisregardRepeated = getShinglesDisregardRepeated;\r\n/**\r\n *\r\n * @param {Array<Array<string>>}\r\n * @return {Array<Array<number>>} number : 0 | 1;\r\n * Normalize the tokens/shingles to binary vectors that are 0s or 1s.\r\n */\r\nfunction normalizeToVectors(matrix) {\r\n    var result = [];\r\n    var union = {};\r\n    var lineLookUp = []; //strings in each line will be a lookUp table\r\n    var matrixLength = matrix.length;\r\n    // 1 get union\r\n    for (var i = 0; i < matrixLength; i++) {\r\n        lineLookUp[i] = {};\r\n        for (var j = 0; j < matrix[i].length; j++) {\r\n            var key = matrix[i][j];\r\n            // save to union if key does not exist\r\n            if (!union[key]) {\r\n                union[key] = 1;\r\n            }\r\n            // save this key to line look up table itself.\r\n            lineLookUp[i][key] = 1;\r\n        }\r\n    }\r\n    // 2 normalize strings to vectors\r\n    var unionKeys = Object.keys(union);\r\n    for (var i = 0; i < matrixLength; i++) {\r\n        var row = new Array(unionKeys.length); // this will be the normalized vector from the original shingles/strings\r\n        for (var j = 0; j < unionKeys.length; j++) {\r\n            var key = unionKeys[j];\r\n            if (lineLookUp[i][key]) {\r\n                row[j] = 1;\r\n            }\r\n            else {\r\n                row[j] = 0;\r\n            }\r\n        }\r\n        result.push(row);\r\n    }\r\n    return result;\r\n}\r\nexports.normalizeToVectors = normalizeToVectors;\r\n/**\r\n *\r\n * @param arrayLength : number\r\n * @returns : Array<number>\r\n *\r\n * Function works similar to permutating an array\r\n */\r\nfunction randomPermutationGenerator(size /** the size of the permutation you want to create */, isBinary) {\r\n    // 1 Initialization\r\n    var baseArray = new Array(size);\r\n    if (!isBinary) {\r\n        for (var i = 0; i < size; i++) {\r\n            baseArray[i] = i;\r\n        }\r\n    }\r\n    else {\r\n        var numOfOnes = Math.floor(Math.random() * size + 1);\r\n        for (var i = 0; i < size; i++) {\r\n            if (numOfOnes > 0) {\r\n                baseArray[i] = 1;\r\n                numOfOnes--;\r\n            }\r\n            else {\r\n                baseArray[i] = 0;\r\n            }\r\n        }\r\n    }\r\n    return {\r\n        /**\r\n         *\r\n         * @returns the original array when it is initialized\r\n         */\r\n        shuffle: function () {\r\n            for (var i = 0; i < size - 1; i++) {\r\n                var swapIndex = Math.floor(Math.random() * (size - i));\r\n                //swap\r\n                var temp = baseArray[i];\r\n                baseArray[i] = baseArray[swapIndex + i];\r\n                baseArray[swapIndex + i] = temp;\r\n            }\r\n            return baseArray;\r\n        },\r\n        /**\r\n         *\r\n         * @returns a new array which used extra memory\r\n         */\r\n        shuffleNew: function () {\r\n            var copiedArray = __spreadArray([], __read(baseArray));\r\n            for (var i = 0; i < size - 1; i++) {\r\n                var swapIndex = Math.floor(Math.random() * (size - i));\r\n                //swap\r\n                var temp = copiedArray[i];\r\n                copiedArray[i] = copiedArray[swapIndex + i];\r\n                copiedArray[swapIndex + i] = temp;\r\n            }\r\n            return copiedArray;\r\n        }\r\n    };\r\n}\r\nexports.randomPermutationGenerator = randomPermutationGenerator;\r\nfunction getDotProduct(vector1, vector2) {\r\n    if (vector1.length !== vector2.length) {\r\n        throw new TypeError(\"Two vectors' length are not equal\");\r\n    }\r\n    var res = 0;\r\n    for (var i = 0; i < vector1.length; i++) {\r\n        res += vector1[i] * vector2[i];\r\n    }\r\n    return res;\r\n}\r\nexports.getDotProduct = getDotProduct;\r\nfunction getVectorLength(vector) {\r\n    var res = 0;\r\n    for (var i = 0; i < vector.length; i++) {\r\n        res += vector[i] * vector[i];\r\n    }\r\n    return Math.sqrt(res);\r\n}\r\nexports.getVectorLength = getVectorLength;\r\n","\"use strict\";\r\nvar __read = (this && this.__read) || function (o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.getJaccardSim = exports.getCosDistance = exports.getLvstnDistance = void 0;\r\nvar common_1 = require(\"./common\");\r\nfunction getLvstnDistance(string1, string2) {\r\n    //dp init\r\n    var dp = new Array(string1.length + 1);\r\n    for (var i = 0; i < dp.length; i++) {\r\n        dp[i] = new Array(string2.length + 1);\r\n    }\r\n    //assign values\r\n    dp[0][0] = 0;\r\n    for (var i = 1; i < dp.length; i++) {\r\n        dp[i][0] = i;\r\n    }\r\n    for (var i = 1; i < dp[0].length; i++) {\r\n        dp[0][i] = i;\r\n    }\r\n    for (var i = 1; i < dp.length; i++) {\r\n        for (var j = 1; j < dp[i].length; j++) {\r\n            if (string1.charAt(i - 1) === string2.charAt(j - 1))\r\n                dp[i][j] = dp[i - 1][j - 1];\r\n            else\r\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i - 1][j - 1], dp[i][j - 1]) + 1;\r\n        }\r\n    }\r\n    return dp[string1.length][string2.length];\r\n}\r\nexports.getLvstnDistance = getLvstnDistance;\r\nfunction getCosDistance(shingles1, shingles2) {\r\n    var _a = __read(common_1.normalizeToVectors([shingles1, shingles2]), 2), vec1 = _a[0], vec2 = _a[1];\r\n    var dotProduct = common_1.getDotProduct(vec1, vec2);\r\n    var vecLen1 = 0;\r\n    var vecLen2 = 0;\r\n    for (var i = 0; i < vec1.length; i++) {\r\n        vecLen1 += Math.pow(vec1[i], 2);\r\n        vecLen2 += Math.pow(vec2[i], 2);\r\n    }\r\n    return vecLen1 === vecLen2 ? dotProduct / vecLen1 : dotProduct / (Math.sqrt(vecLen1) * Math.sqrt(vecLen2));\r\n}\r\nexports.getCosDistance = getCosDistance;\r\nfunction getJaccardSim(vector1, vector2) {\r\n    if (vector1.length !== vector2.length) {\r\n        throw new Error(\"Unmatched vector length\");\r\n    }\r\n    var intersections = 0;\r\n    var unions = 0;\r\n    for (var i = 0; i < vector1.length; i++) {\r\n        if (vector1[i] !== vector2[i]) {\r\n            unions++;\r\n        }\r\n        else if (vector1[i] !== 0) {\r\n            unions++;\r\n            intersections++;\r\n        }\r\n    }\r\n    return intersections / unions;\r\n}\r\nexports.getJaccardSim = getJaccardSim;\r\n// export function getJaccardDis(params:type) {\r\n// }\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.findExactItems = void 0;\r\nfunction computeNext(pattern) {\r\n    if (pattern.length <= 0)\r\n        return [];\r\n    var next = new Array(pattern.length);\r\n    var prefix = 0;\r\n    next[0] = 0;\r\n    for (var suffix = 1; suffix < next.length; suffix++) {\r\n        while (prefix > 0 && pattern.charAt(prefix) !== pattern.charAt(suffix))\r\n            prefix = next[prefix - 1];\r\n        if (pattern.charAt(prefix) === pattern.charAt(suffix))\r\n            prefix++;\r\n        next[suffix] = prefix;\r\n    }\r\n    return next;\r\n}\r\nfunction findExactItems(pattern) {\r\n    //concrete \"next\" array for this pattern;\r\n    var next = computeNext(pattern);\r\n    //right move the next\r\n    for (var i = next.length - 1; i >= 1; i--) {\r\n        next[i] = next[i - 1];\r\n    }\r\n    next[0] = -1;\r\n    return {\r\n        findAll: function (haystack) {\r\n            var result = [];\r\n            var haystackPointer = 0;\r\n            var patternPointer = 0;\r\n            while (haystackPointer < haystack.length) {\r\n                // no char is matched, it will next index to be matching according to \"next\" array\r\n                if (haystack.charAt(haystackPointer) !== pattern.charAt(patternPointer)) {\r\n                    if (next[patternPointer] === -1) { // no sub-pattern is found, needs to move the haystack pointer forward\r\n                        haystackPointer++;\r\n                    }\r\n                    else {\r\n                        patternPointer = next[patternPointer];\r\n                    }\r\n                }\r\n                else {\r\n                    // found matched char\r\n                    haystackPointer++;\r\n                    patternPointer++;\r\n                    if (patternPointer >= pattern.length) {\r\n                        result.push(haystackPointer - pattern.length);\r\n                        haystackPointer = haystackPointer - pattern.length + 1; // only move the index, from matched string, 1 forward\r\n                        patternPointer = 0;\r\n                    }\r\n                }\r\n            }\r\n            return result;\r\n        },\r\n        findFirst: function (haystack) {\r\n            var result = -1;\r\n            var haystackPointer = 0;\r\n            var patternPointer = 0;\r\n            while (haystackPointer < haystack.length) {\r\n                // no char is matched, it will next index to be matching according to \"next\" array\r\n                if (haystack.charAt(haystackPointer) !== pattern.charAt(patternPointer)) {\r\n                    if (next[patternPointer] === -1) { // no sub-pattern is found, needs to move the haystack pointer forward\r\n                        haystackPointer++;\r\n                    }\r\n                    else {\r\n                        patternPointer = next[patternPointer];\r\n                    }\r\n                }\r\n                else {\r\n                    // found matched char\r\n                    haystackPointer++;\r\n                    patternPointer++;\r\n                    if (patternPointer >= pattern.length) {\r\n                        result = haystackPointer - pattern.length;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n    };\r\n}\r\nexports.findExactItems = findExactItems;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.getSimilarity = exports.findSimilarItems = void 0;\r\nvar distanceCalculator_1 = require(\"../common/distanceCalculator\");\r\nvar common_1 = require(\"../common/common\");\r\nvar defaultSettings = {\r\n    isCaseSensitive: true,\r\n    lineToLeft: false,\r\n};\r\nfunction findSimilarItems(haystacks, pattern, settings) {\r\n    //pre-configure settings \r\n    Object.setPrototypeOf(settings, defaultSettings);\r\n    var isCaseSensitive = settings.isCaseSensitive, lineToLeft = settings.lineToLeft;\r\n    var similarItems = [];\r\n    if (!isCaseSensitive)\r\n        pattern = pattern.toLowerCase();\r\n    for (var i = 0; i < haystacks.length; i++) {\r\n        var haystack = \"\";\r\n        if (lineToLeft) {\r\n            haystack = haystacks[i].substring(0, pattern.length);\r\n        }\r\n        else {\r\n            haystack = haystacks[i];\r\n        }\r\n        if (!isCaseSensitive) {\r\n            haystack = haystack.toLowerCase();\r\n        }\r\n        var sim = getSimilarity(haystack, pattern);\r\n        similarItems.push({\r\n            string: haystacks[i],\r\n            similarity: sim\r\n        });\r\n    }\r\n    similarItems.sort(function (obj1, obj2) { return obj2.similarity - obj1.similarity; }); // decreasing order\r\n    return similarItems;\r\n}\r\nexports.findSimilarItems = findSimilarItems;\r\nfunction getSimilarity(string1, string2) {\r\n    var shingleLenth = 2;\r\n    var cosSimWeight = 50;\r\n    var cosSim = distanceCalculator_1.getCosDistance(common_1.getShinglesDisregardRepeated(string1, shingleLenth), common_1.getShinglesDisregardRepeated(string2, shingleLenth));\r\n    var lvstnSim = 1 - distanceCalculator_1.getLvstnDistance(string1, string2) / (Math.max(string1.length, string2.length));\r\n    return cosSim * cosSimWeight + lvstnSim * (100 - cosSimWeight);\r\n}\r\nexports.getSimilarity = getSimilarity;\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./index.ts\");\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;ACrMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;;;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACvBA;AACA;AACA;AACA;;;;;A","sourceRoot":""}